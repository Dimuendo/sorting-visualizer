{"version":3,"sources":["SortingAlgorithms/sortingAlgs.js","SortingVisualizer/SortingScript.jsx","App.js","serviceWorker.js","index.js"],"names":["AnimationMerge","compare","overwrite","type","this","mergeSortHelper","rects","animationsMerge","rectsLength","length","mid","Math","floor","left","slice","right","animationMerge","sortedArr","leftLength","rightLength","l","r","currIndex","push","value","merge","AnimationQuick","swap","choosePivot","choosePartition","quickSort","animationsQuick","quickSortHelper","low","high","partitionIndex","pivot","animationQuick","pivotValue","i","partition","AnimationBub","bubbleSort","animationsBub","animationBub","j","bubbleSortHelper","AnimationSelect","chooseMin","selectionSort","animationsSelect","animationSelect","minIndex","len","selectionSortHelper","tempIndex","temp","Rectangle","SortingVisualizer","props","state","barWidth","animationSpeed","updateRectSize","bind","updateSpeed","resetRects","rectList","document","getElementsByClassName","style","width","min","max","screenWidth","window","innerWidth","screenHeight","innerHeight","numRects","rand","random","tempRect","setState","event","sliderValue","target","rectsIn","values","generateButton","getElementById","disabled","color","mergeButton","quickButton","bubbleButton","selectButton","sliders","sliderTexts","console","log","sortingAlgs","lockButtons","animationTimer","aniType","rectOneIndex","rectTwoIndex","rectOneStyle","rectTwoStyle","setTimeout","backgroundColor","newHeight","height","sortedRects","resetRectIndices","resetButtons","tempHeight","pivotRectIndex","pivotRectStyle","partitionRectIndex","partitionRectStyle","lastMinIndex","currMinIndex","currMinRectStyle","lastMinRectStyle","className","id","onClick","step","defaultValue","onChange","mergeSort","map","rect","index","key","React","Component","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.4adcb7f4.chunk.js","sourcesContent":["///////////////////////////////////////////////////////////////////////////////\r\n//                              MERGE SORT                                   //\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nclass AnimationMerge {\r\n    constructor(compare, overwrite, type) {\r\n        this.compare = compare;\r\n        this.overwrite = overwrite;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\nexport function mergeSort(rects) {\r\n    const animationsMerge = [];\r\n    rects = mergeSortHelper(rects, animationsMerge);\r\n    console.log(rects);\r\n    return animationsMerge;\r\n}\r\n\r\nexport function mergeSortHelper(rects, animationsMerge) {\r\n    let rectsLength = rects.length;\r\n\tif (rectsLength < 2) return rects;\r\n\r\n\tlet mid = Math.floor(rectsLength / 2);\r\n\tlet left = rects.slice(0, mid);\r\n\tlet right = rects.slice(mid);\r\n\r\n\treturn merge(mergeSortHelper(left, animationsMerge), mergeSortHelper(right, animationsMerge), animationsMerge);\r\n}\r\n\r\nfunction merge(left, right, animationsMerge) {\r\n\tlet sortedArr = [];\r\n\tlet leftLength = left.length;\r\n\tlet rightLength = right.length;\r\n\tlet l = 0;\r\n\tlet r = 0;\r\n    let currIndex = left[0].currIndex;\r\n    let animationMerge;\r\n\r\n\twhile (l < leftLength && r < rightLength) {\r\n        animationMerge = new AnimationMerge([left[l].currIndex, right[r].currIndex], 0, 'compare');\r\n        animationsMerge.push(animationMerge);\r\n\t\tif (left[l].value < right[r].value) {\r\n            animationMerge = new AnimationMerge(0, [currIndex, left[l].value], 'overwrite');\r\n            animationsMerge.push(animationMerge);\r\n            left[l].currIndex = currIndex;\r\n            currIndex++;\r\n            sortedArr.push(left[l]);\r\n\t\t\tl++;\r\n\t\t} else {\r\n            animationMerge = new AnimationMerge(0, [currIndex, right[r].value], 'overwrite');\r\n            animationsMerge.push(animationMerge);\r\n            right[r].currIndex = currIndex;\r\n            currIndex++;\r\n\t\t\tsortedArr.push(right[r]);\r\n\t\t\tr++;\r\n        }\r\n\t}\r\n\r\n\twhile (l < leftLength) {\r\n        left[l].currIndex = currIndex;\r\n        animationMerge = new AnimationMerge(0, [currIndex, left[l].value], 'overwrite');\r\n        animationsMerge.push(animationMerge);\r\n        currIndex++;\r\n\t\tsortedArr.push(left[l]);\r\n\t\tl++;\r\n\t}\r\n\r\n\twhile (r < rightLength) {\r\n        right[r].currIndex = currIndex;\r\n        animationMerge = new AnimationMerge(0, [currIndex, right[r].value], 0, 'overwrite');\r\n        animationsMerge.push(animationMerge);\r\n        currIndex++;\r\n\t\tsortedArr.push(right[r]);\r\n\t\tr++;\r\n    }\r\n    \r\n\treturn sortedArr;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n//                              QUICK SORT                                   //\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nclass AnimationQuick {\r\n    constructor(compare, swap, choosePivot, choosePartition, type) {\r\n        this.compare = compare;\r\n        this.swap = swap;\r\n        this.choosePivot = choosePivot;\r\n        this.choosePartition = choosePartition;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\nexport function quickSort(rects) {\r\n    const animationsQuick = [];\r\n    const rectsLength = rects.length - 1;\r\n    \r\n    quickSortHelper(rects, 0, rectsLength, animationsQuick);\r\n    return animationsQuick;\r\n}\r\n\r\nfunction quickSortHelper(rects, low, high, animationsQuick) {\r\n    let pivot;\r\n    let partitionIndex;\r\n\r\n    if (low < high) {\r\n        pivot = high;\r\n        partitionIndex = partition(rects, pivot, low, high, animationsQuick)\r\n\r\n        quickSortHelper(rects, low, partitionIndex - 1, animationsQuick);\r\n        quickSortHelper(rects, partitionIndex + 1, high, animationsQuick);\r\n    }\r\n    return rects;\r\n}\r\n\r\nfunction partition(rects, pivot, low, high, animationsQuick) {\r\n    let pivotValue = rects[pivot];\r\n    let partitionIndex = low;\r\n    let animationQuick;\r\n\r\n    animationQuick = new AnimationQuick(0, 0, pivot, 0, 'choosePivot');\r\n    animationsQuick.push(animationQuick);\r\n    animationQuick = new AnimationQuick(0, 0, 0, partitionIndex, 'choosePartition');\r\n    animationsQuick.push(animationQuick);\r\n\r\n    for (let i = low; i < high; i++) {\r\n        animationQuick = new AnimationQuick(i, 0, 0, 0, 'compare');\r\n        animationsQuick.push(animationQuick);\r\n        if (rects[i].value < pivotValue.value) {\r\n            if (i === partitionIndex) {\r\n                partitionIndex++;\r\n                continue;\r\n            }\r\n            animationQuick = new AnimationQuick(0, [i, partitionIndex], 0, 0, 'swap');\r\n            animationsQuick.push(animationQuick);\r\n            swap(rects, i, partitionIndex);\r\n            partitionIndex++;\r\n            animationQuick = new AnimationQuick(0, 0, 0, partitionIndex, 'choosePartition');\r\n            animationsQuick.push(animationQuick);\r\n        }\r\n    }\r\n    animationQuick = new AnimationQuick(0, [high, partitionIndex], 0, 0, 'swap');\r\n    animationsQuick.push(animationQuick);\r\n    swap(rects, high, partitionIndex);\r\n\r\n    return partitionIndex;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n//                              BUBBLE SORT                                  //\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nclass AnimationBub {\r\n    constructor(compare, swap, type) {\r\n        this.compare = compare;\r\n        this.swap = swap;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\nexport function bubbleSort(rects) {\r\n    const animationsBub = [];\r\n    bubbleSortHelper(rects, animationsBub);\r\n    return animationsBub;\r\n}\r\n\r\nfunction bubbleSortHelper(rects, animationsBub) {\r\n    let len = rects.length;\r\n    let animationBub;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        for (let j = 1; j <= i; j++) {\r\n            animationBub = new AnimationBub([j, j-1], 0, 'compare');\r\n            animationsBub.push(animationBub);\r\n            if (rects[j - 1].value > rects[j].value) {\r\n                animationBub = new AnimationBub(0, [j, j-1], 'swap');\r\n                animationsBub.push(animationBub);\r\n                swap(rects, j-1, j);\r\n            }\r\n        }\r\n    }\r\n    return rects;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n//                              SELECTION SORT                               //\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nclass AnimationSelect {\r\n    constructor(compare, swap, chooseMin, type) {\r\n        this.compare = compare;\r\n        this.swap = swap;\r\n        this.chooseMin = chooseMin;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\nexport function selectionSort(rects) {\r\n    const animationsSelect = [];\r\n    selectionSortHelper(rects, animationsSelect);\r\n    return animationsSelect;\r\n}\r\n\r\nexport function selectionSortHelper(rects, animationsSelect) {\r\n    let minIndex = -1;\r\n    let len = rects.length;\r\n    let animationSelect;\r\n    let lastMin;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        lastMin = minIndex;\r\n        minIndex = i;\r\n        animationSelect = new AnimationSelect(0, 0, [lastMin, minIndex], 'chooseMin');\r\n        animationsSelect.push(animationSelect);\r\n        for (let j = i + 1; j < len; j++) {\r\n            animationSelect = new AnimationSelect(j, 0, 0, 'compare');\r\n            animationsSelect.push(animationSelect);\r\n            if (rects[j].value < rects[minIndex].value) {\r\n                lastMin = minIndex;\r\n                minIndex = j;\r\n                animationSelect = new AnimationSelect(0, 0, [lastMin, minIndex], 'chooseMin');\r\n                animationsSelect.push(animationSelect);\r\n            }\r\n        }\r\n        animationSelect = new AnimationSelect(0, [i, minIndex], 0, 'swap');\r\n        animationsSelect.push(animationSelect);\r\n        swap(rects, i, minIndex);\r\n    }\r\n    return rects;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n//                              USEFUL FUNCTIONS                             //\r\n///////////////////////////////////////////////////////////////////////////////\r\nfunction swap(rects, i, j) {\r\n    const tempIndex = rects[i].currIndex;\r\n    rects[i].currIndex = rects[j].currIndex;\r\n    rects[j].currIndex = tempIndex;\r\n\r\n    const temp = rects[i];\r\n    rects[i] = rects[j];\r\n    rects[j] = temp;\r\n}\r\n","import React from 'react';\r\nimport './SortingVisualizer.css';\r\nimport * as sortingAlgs from '../SortingAlgorithms/sortingAlgs';\r\n\r\nconst ORIGINAL_COLOUR = 'darkviolet';\r\n\r\nclass Rectangle {\r\n    constructor(value, currIndex) {\r\n        this.value = value;\r\n        this.currIndex = currIndex;\r\n    }\r\n}\r\n\r\nexport default class SortingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            rects: [],\r\n            barWidth: 17,\r\n            animationSpeed: 8,\r\n        };\r\n\r\n        this.updateRectSize = this.updateRectSize.bind(this);\r\n        this.updateSpeed = this.updateSpeed.bind(this);\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resetRects(this.state.barWidth * 10 + 2);\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        // Update the width of the all the rectangle elements when the number of rects change\r\n        const rectList = document.getElementsByClassName('rect');\r\n        for (let i = 0; i < rectList.length; i++) {\r\n            rectList[i].style.width = `${this.state.barWidth}px`;\r\n        }\r\n    }\r\n\r\n    resetRects(barWidth) {\r\n        // Create rectangles based on screen size\r\n        barWidth = Math.floor(((barWidth + 2) / 10) + 2);\r\n        const screenWidth = window.innerWidth;\r\n        const screenHeight = window.innerHeight;\r\n        let numRects = (screenWidth / barWidth) - 8;\r\n        const rects = [];\r\n        for (let i = 0; i < numRects; i++) {\r\n            let rand = randValue(10, screenHeight - 100);\r\n            let tempRect = new Rectangle(rand, i);\r\n            rects.push(tempRect);\r\n        }\r\n        this.setState({rects: rects});\r\n    }\r\n\r\n    updateRectSize(event) {\r\n        // Update the rectangle widths whenever the slider moves\r\n        const sliderValue = event.target.value;\r\n        this.setState({\r\n            barWidth: sliderValue,\r\n        });\r\n        this.resetRects(sliderValue); \r\n    }\r\n\r\n    updateSpeed(event) {\r\n        // Update the animation speed whenever the slider moves\r\n        const sliderValue = event.target.value;\r\n        this.setState({animationSpeed: sliderValue});\r\n    }\r\n\r\n    resetRectIndices(rectsIn) {\r\n        // After sorting the rectangles, update their index property\r\n        const values = [];\r\n        for (let i = 0; i < rectsIn.length; i++) {\r\n            values.push(rectsIn[i].value)\r\n        }\r\n        const rects = [];\r\n        for (let i = 0; i < values.length; i++) {\r\n            let tempRect = new Rectangle(values[i], i);\r\n            rects.push(tempRect);\r\n        }\r\n        this.setState({rects: rects});\r\n    }\r\n\r\n    lockButtons() {\r\n        let blockColour = 'gray';\r\n\r\n        let generateButton = document.getElementById('generate-nums');\r\n        generateButton.disabled = true;\r\n        generateButton.style.color = blockColour;\r\n        \r\n        let mergeButton = document.getElementById('merge-sort');\r\n        mergeButton.disabled = true;\r\n        mergeButton.style.color = blockColour;\r\n\r\n        let quickButton = document.getElementById('quick-sort');\r\n        quickButton.disabled = true;\r\n        quickButton.style.color = blockColour;\r\n        \r\n        let bubbleButton = document.getElementById('bubble-sort');\r\n        bubbleButton.disabled = true;\r\n        bubbleButton.style.color = blockColour;\r\n\r\n        let selectButton = document.getElementById('selection-sort');\r\n        selectButton.disabled = true;\r\n        selectButton.style.color = blockColour;\r\n\r\n        let sliders = document.getElementsByClassName('slider');\r\n        for (let i = 0; i < sliders.length; i++) {\r\n            sliders[i].disabled = true;\r\n        }\r\n\r\n        let sliderTexts = document.getElementsByClassName('slider-text');\r\n        for (let i = 0; i < sliderTexts.length; i++) {\r\n            sliderTexts[i].style.color = blockColour;\r\n        }\r\n    }\r\n\r\n    resetButtons() {\r\n        let unblockedColour = 'white';\r\n\r\n        let generateButton = document.getElementById('generate-nums');\r\n        generateButton.disabled = false;\r\n        generateButton.style.color = unblockedColour;\r\n        \r\n        let mergeButton = document.getElementById('merge-sort');\r\n        mergeButton.disabled = false;\r\n        mergeButton.style.color = unblockedColour;\r\n\r\n        let quickButton = document.getElementById('quick-sort');\r\n        quickButton.disabled = false;\r\n        quickButton.style.color = unblockedColour;\r\n        \r\n        let bubbleButton = document.getElementById('bubble-sort');\r\n        bubbleButton.disabled = false;\r\n        bubbleButton.style.color = unblockedColour;\r\n\r\n        let selectButton = document.getElementById('selection-sort');\r\n        selectButton.disabled = false;\r\n        selectButton.style.color = unblockedColour;\r\n\r\n        let sliders = document.getElementsByClassName('slider');\r\n        for (let i = 0; i < sliders.length; i++) {\r\n            sliders[i].disabled = false;\r\n        }\r\n\r\n        let sliderTexts = document.getElementsByClassName('slider-text');\r\n        for (let i = 0; i < sliderTexts.length; i++) {\r\n            sliderTexts[i].style.color = unblockedColour;\r\n        }\r\n    }\r\n\r\n    mergeSort(animationSpeed) {\r\n        // Get the animations assoicated with the sort\r\n        const animationsMerge = sortingAlgs.mergeSort(this.state.rects);\r\n        this.lockButtons();\r\n        let animationTimer = 0;\r\n        \r\n        // Loop through the animations\r\n        for (let i = 0; i < animationsMerge.length; i++) {\r\n            const rectList = document.getElementsByClassName('rect');\r\n            const aniType = animationsMerge[i].type;\r\n            \r\n            // If it's a comparison, colour the two rectangles red then colour them back to original\r\n            if (aniType === 'compare') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsMerge[i].compare;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                let colour = 'red';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                    rectTwoStyle.backgroundColor = colour;\r\n                }, animationTimer * animationSpeed);\r\n                animationTimer++;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                    rectTwoStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 5) * animationSpeed);\r\n                animationTimer += 5;\r\n            \r\n            // If it's an overwrite, change the height of the rectangle at the index given\r\n            } else if (aniType === 'overwrite') {\r\n                const [rectOneIndex, newHeight] = animationsMerge[i].overwrite;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const colour = 'darkblue';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                    rectOneStyle.height = `${newHeight}px`;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n            }\r\n        }\r\n\r\n        // Unlock the buttons once the animations are done\r\n        setTimeout(() => {\r\n            const sortedRects = sortingAlgs.mergeSortHelper(this.state.rects, []);\r\n            this.resetRectIndices(sortedRects);\r\n            this.resetButtons();\r\n        }, (animationTimer + 1) * animationSpeed);\r\n    }\r\n\r\n    quickSort(animationSpeed) {\r\n        const animationsQuick = sortingAlgs.quickSort(this.state.rects);\r\n        this.lockButtons();\r\n        let animationTimer = 0;\r\n\r\n        for (let i = 0; i < animationsQuick.length; i++) {\r\n            const rectList = document.getElementsByClassName('rect');\r\n            const aniType = animationsQuick[i].type;\r\n\r\n            // If it's a comparison, colour the rectangle red (the rect we are comparing against is the pivot)\r\n            if (aniType === 'compare') {\r\n                const rectOneIndex = animationsQuick[i].compare;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const colour = 'red';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                }, animationTimer * animationSpeed);\r\n                animationTimer++;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 5) * animationSpeed);\r\n                animationTimer += 6;\r\n\r\n            // If it's a swap, colour the two rectangles, swap their heights, colour them back to original\r\n            } else if (aniType === 'swap') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsQuick[i].swap;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                const colourOne = 'darkblue';\r\n                const colourTwo = 'blue';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colourOne;\r\n                    rectTwoStyle.backgroundColor = colourTwo;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n                setTimeout(() => {\r\n                    const tempHeight = rectOneStyle.height;\r\n                    rectOneStyle.height = rectTwoStyle.height;\r\n                    rectTwoStyle.height = tempHeight;\r\n                    rectOneStyle.backgroundColor = colourTwo;\r\n                    rectTwoStyle.backgroundColor = colourOne;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                    rectTwoStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n\r\n            // If we are choosing a pivot, colour the pivot red\r\n            } else if (aniType === 'choosePivot') {\r\n                const pivotRectIndex = animationsQuick[i].choosePivot;\r\n                const pivotRectStyle = rectList[pivotRectIndex].style;\r\n                const colour = 'red';\r\n                setTimeout(() => {\r\n                    pivotRectStyle.backgroundColor = colour;\r\n                }, animationTimer * animationSpeed);\r\n                animationTimer++;\r\n\r\n            // If we are choosing a partition, colour the partition black\r\n            } else if (aniType === 'choosePartition') {\r\n                const partitionRectIndex = animationsQuick[i].choosePartition;\r\n                const partitionRectStyle = rectList[partitionRectIndex].style;\r\n                const colour = 'black';\r\n                setTimeout(() => {\r\n                    partitionRectStyle.backgroundColor = colour;\r\n                }, animationTimer * animationSpeed);\r\n                animationTimer++;\r\n            }\r\n        }\r\n\r\n        // Unlock the buttons once the animations are done\r\n        setTimeout(() => {\r\n            this.resetRectIndices(this.state.rects);\r\n            this.resetButtons();\r\n        }, (animationTimer + 1) * animationSpeed);\r\n    }\r\n\r\n    bubbleSort(animationSpeed) {\r\n        const animationsBub = sortingAlgs.bubbleSort(this.state.rects);\r\n        this.lockButtons();\r\n        let animationTimer = 0;\r\n\r\n        for (let i = 0; i < animationsBub.length; i++) {\r\n            const rectList = document.getElementsByClassName('rect');\r\n            const aniType = animationsBub[i].type;\r\n\r\n            // If it's a comparison, colour the two rectangles red then colour them back to original\r\n            if (aniType === 'compare') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsBub[i].compare;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                let colour = 'red';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                    rectTwoStyle.backgroundColor = colour;\r\n                }, animationTimer * animationSpeed);\r\n                animationTimer++;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                    rectTwoStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 5) * animationSpeed);\r\n                animationTimer += 5;\r\n\r\n            // If it's a swap, colour the two rectangles, swap their heights, colour them back to original\r\n            } else if (aniType === 'swap') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsBub[i].swap;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                const colourOne = 'darkblue';\r\n                const colourTwo = 'blue';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colourOne;\r\n                    rectTwoStyle.backgroundColor = colourTwo;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n                setTimeout(() => {\r\n                    const tempHeight = rectOneStyle.height;\r\n                    rectOneStyle.height = rectTwoStyle.height;\r\n                    rectTwoStyle.height = tempHeight;\r\n                    rectOneStyle.backgroundColor = colourTwo;\r\n                    rectTwoStyle.backgroundColor = colourOne;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                    rectTwoStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n            }\r\n        }\r\n\r\n        // Unlock the buttons once the animations are done\r\n        setTimeout(() => {\r\n            this.resetRectIndices(this.state.rects);\r\n            this.resetButtons();\r\n        }, (animationTimer + 1) * animationSpeed);\r\n    }\r\n\r\n    selectionSort(animationSpeed) {\r\n        const animationsSelect = sortingAlgs.selectionSort(this.state.rects);\r\n        this.lockButtons();\r\n        let animationTimer = 0;\r\n\r\n        for (let i = 0; i < animationsSelect.length; i++) {\r\n            const rectList = document.getElementsByClassName('rect');\r\n            const aniType = animationsSelect[i].type;\r\n\r\n            // If it's a comparison, colour the two rectangles red then colour them back to original\r\n            if (aniType === 'compare') {\r\n                const rectOneIndex = animationsSelect[i].compare;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const colour = 'red';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                }, animationTimer * animationSpeed);\r\n                animationTimer++;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 5) * animationSpeed);\r\n                animationTimer += 6;\r\n\r\n            // If we are the updating the min, colour the new min black and colour the previous min back to original\r\n            } else if (aniType === 'chooseMin') {\r\n                const [lastMinIndex, currMinIndex] = animationsSelect[i].chooseMin;\r\n                const currMinRectStyle = rectList[currMinIndex].style;\r\n                const colour = 'black';\r\n                if (lastMinIndex >= 0) {\r\n                    const lastMinRectStyle = rectList[lastMinIndex].style;\r\n                    setTimeout(() => {\r\n                        lastMinRectStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                        currMinRectStyle.backgroundColor = colour;\r\n                    }, (animationTimer) * animationSpeed);\r\n                    animationTimer++;\r\n                } else {\r\n                    setTimeout(() => {\r\n                        currMinRectStyle.backgroundColor = colour;\r\n                    }, (animationTimer) * animationSpeed);\r\n                }\r\n\r\n            // If it's a swap, colour the two rectangles, swap their heights, colour them back to original\r\n            } else if (aniType === 'swap') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsSelect[i].swap;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                const colourOne = 'darkblue';\r\n                const colourTwo = 'blue';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colourOne;\r\n                    rectTwoStyle.backgroundColor = colourTwo;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n                setTimeout(() => {\r\n                    const tempHeight = rectOneStyle.height;\r\n                    rectOneStyle.height = rectTwoStyle.height;\r\n                    rectTwoStyle.height = tempHeight;\r\n                    rectOneStyle.backgroundColor = colourTwo;\r\n                    rectTwoStyle.backgroundColor = colourOne;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                    rectTwoStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 10) * animationSpeed);\r\n                animationTimer += 11;\r\n            }\r\n        }\r\n\r\n        // Unlock the buttons once the animations are done\r\n        setTimeout(() => {\r\n            this.resetRectIndices(this.state.rects);\r\n            this.resetButtons();\r\n        }, (animationTimer + 1) * animationSpeed);\r\n    }\r\n\r\n    render() {\r\n        const {rects} = this.state;\r\n        return (\r\n            <div className=\"container\">\r\n                <div className=\"options-bar\">\r\n                    <button id=\"generate-nums\" onClick={() => this.resetRects(this.state.barWidth * 10 + 2)}> Generate Numbers  </button>\r\n                    <div className=\"slide-container\">\r\n                        <p className=\"slider-text\">Set Array Size: </p>\r\n                        <input type=\"range\" id=\"num-slider\" min=\"1\" max=\"32\" step=\"1\" defaultValue={this.state.barWidth} className=\"slider\" onChange={this.updateRectSize}></input>\r\n                        <p className=\"slider-text\">Set Animation Speed: </p>\r\n                        <input type=\"range\" id=\"speed-slider\" min=\"1\" max=\"15\" step=\"1\" defaultValue={this.state.animationSpeed} className=\"slider\" onChange={this.updateSpeed}></input>\r\n                    </div>\r\n                    <button id=\"quick-sort\" onClick={() => this.quickSort(this.state.animationSpeed)}> Quick Sort  </button>\r\n                    <button id=\"bubble-sort\" onClick={() => this.bubbleSort(this.state.animationSpeed)}> Bubble Sort  </button>\r\n                    <button id=\"merge-sort\" onClick={() => this.mergeSort(this.state.animationSpeed)}> Merge Sort  </button>\r\n                    <button id=\"selection-sort\" onClick={() => this.selectionSort(this.state.animationSpeed)}> Selection Sort  </button>\r\n                </div>\r\n                <div className=\"rect-container\">\r\n                    {rects.map((rect, index) => (\r\n                        <div className=\"rect\" key={index} style={{height: `${rect.value}px`}} >\r\n                        </div>\r\n                    ))}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction randValue(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n","import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingScript';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}