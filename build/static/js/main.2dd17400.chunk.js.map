{"version":3,"sources":["SortingAlgorithms/sortingAlgs.js","SortingVisualizer/SortingScript.jsx","App.js","serviceWorker.js","index.js"],"names":["mergeSortHelper","rects","animationsMerge","rectsLength","length","mid","Math","floor","left","slice","right","sortedArr","leftLength","rightLength","l","r","currIndex","push","value","merge","AnimationQuick","compare","swap","type","this","quickSort","animationsQuick","quickSortHelper","low","high","partitionIndex","pivot","animationQuick","pivotValue","i","partition","AnimationBub","bubbleSort","animationsBub","animationBub","j","bubbleSortHelper","temp","Rectangle","SortingVisualizer","props","state","resetRects","screenHeight","window","innerHeight","rand","randValue","tempRect","setState","rectsIn","values","generateButton","document","getElementById","disabled","style","color","mergeButton","quickButton","bubbleButton","selectButton","console","log","sortingAlgs","lockButtons","animationTimer","rectList","getElementsByClassName","rectOneIndex","rectTwoIndex","rectOneStyle","rectTwoStyle","colour","setTimeout","backgroundColor","newHeight","height","sortedRects","resetRectIndices","resetButtons","aniType","tempHeight","className","id","onClick","mergeSort","selectionSort","map","rect","index","key","React","Component","min","max","random","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"6TAWO,SAASA,EAAgBC,EAAOC,GACnC,IAAIC,EAAcF,EAAMG,OAC3B,GAAID,EAAc,EAAG,OAAOF,EAE5B,IAAII,EAAMC,KAAKC,MAAMJ,EAAc,GAC/BK,EAAOP,EAAMQ,MAAM,EAAGJ,GACtBK,EAAQT,EAAMQ,MAAMJ,GAExB,OAGD,SAAeG,EAAME,EAAOR,GAC3B,IAAIS,EAAY,GACZC,EAAaJ,EAAKJ,OAClBS,EAAcH,EAAMN,OACpBU,EAAI,EACJC,EAAI,EACDC,EAAYR,EAAK,GAAGQ,UAE3B,KAAOF,EAAIF,GAAcG,EAAIF,GACtBX,EAAgBe,KAAK,CAACT,EAAKM,GAAGE,UAAWN,EAAMK,GAAGC,YAClDd,EAAgBe,KAAK,CAACT,EAAKM,GAAGE,UAAWN,EAAMK,GAAGC,YACpDR,EAAKM,GAAGI,MAAQR,EAAMK,GAAGG,OACnBhB,EAAgBe,KAAK,CAACD,EAAWR,EAAKM,GAAGI,QACzCV,EAAKM,GAAGE,UAAYA,EACpBA,IACAL,EAAUM,KAAKT,EAAKM,IAC7BA,MAESZ,EAAgBe,KAAK,CAACD,EAAWN,EAAMK,GAAGG,QAC1CR,EAAMK,GAAGC,UAAYA,EACrBA,IACTL,EAAUM,KAAKP,EAAMK,IACrBA,KAIF,KAAOD,EAAIF,GACJV,EAAgBe,KAAK,CAACT,EAAKM,GAAGE,UAAWR,EAAKM,GAAGE,YACjDd,EAAgBe,KAAK,CAACT,EAAKM,GAAGE,UAAWR,EAAKM,GAAGE,YACjDd,EAAgBe,KAAK,CAACD,EAAWR,EAAKM,GAAGI,QACzCV,EAAKM,GAAGE,UAAYA,EACpBA,IACNL,EAAUM,KAAKT,EAAKM,IACpBA,IAGD,KAAOC,EAAIF,GACJX,EAAgBe,KAAK,CAACP,EAAMK,GAAGC,UAAWN,EAAMK,GAAGC,YACnDd,EAAgBe,KAAK,CAACP,EAAMK,GAAGC,UAAWN,EAAMK,GAAGC,YACnDd,EAAgBe,KAAK,CAACD,EAAWN,EAAMK,GAAGG,QAC1CR,EAAMK,GAAGC,UAAYA,EACrBA,IACNL,EAAUM,KAAKP,EAAMK,IACrBA,IAGD,OAAOJ,EAjDAQ,CAAMnB,EAAgBQ,EAAMN,GAAkBF,EAAgBU,EAAOR,GAAkBA,G,IAwDzFkB,EACF,WAAYC,EAASC,EAAMC,GAAO,oBAC9BC,KAAKH,QAAUA,EACfG,KAAKF,KAAOA,EACZE,KAAKD,KAAOA,GAIb,SAASE,EAAUxB,GACtB,IAAMyB,EAAkB,GAIxB,OAGJ,SAASC,EAAgB1B,EAAO2B,EAAKC,EAAMH,GAEvC,IAAII,EAEAF,EAAMC,IAENC,EAQR,SAAmB7B,EAAO8B,EAAOH,EAAKC,EAAMH,GAKxC,IAJA,IAEIM,EAFAC,EAAahC,EAAM8B,GACnBD,EAAiBF,EAGZM,EAAIN,EAAKM,EAAIL,EAAMK,IACxBF,EAAiB,IAAIZ,EAAe,CAACc,EAAGH,GAAQ,EAAG,WACnDL,EAAgBT,KAAKe,GACjB/B,EAAMiC,GAAGhB,MAAQe,EAAWf,QAC5Bc,EAAiB,IAAIZ,EAAe,EAAG,CAACc,EAAGJ,GAAiB,QAC5DJ,EAAgBT,KAAKe,GACrBV,EAAKrB,EAAOiC,EAAGJ,GACfA,KAMR,OAHAE,EAAiB,IAAIZ,EAAe,EAAG,CAACS,EAAMC,GAAiB,QAC/DJ,EAAgBT,KAAKe,GACrBV,EAAKrB,EAAO4B,EAAMC,GACXA,EA1BcK,CAAUlC,EADnB4B,EACiCD,EAAKC,EAAMH,GAEpDC,EAAgB1B,EAAO2B,EAAKE,EAAiB,EAAGJ,GAChDC,EAAgB1B,EAAO6B,EAAiB,EAAGD,EAAMH,IAErD,OAAOzB,EAfP0B,CAAgB1B,EAAO,EAFHA,EAAMG,OAAS,EAEIsB,GAChCA,E,IA0CLU,EACF,WAAYf,EAASC,EAAMC,GAAO,oBAC9BC,KAAKH,QAAUA,EACfG,KAAKF,KAAOA,EACZE,KAAKD,KAAOA,GAIb,SAASc,EAAWpC,GACvB,IAAMqC,EAAgB,GAEtB,OAGJ,SAA0BrC,EAAOqC,GAG7B,IAFA,IACIC,EACKL,EAFCjC,EAAMG,OAEG,EAAG8B,GAAK,EAAGA,IAC1B,IAAK,IAAIM,EAAI,EAAGA,GAAKN,EAAGM,IACpBD,EAAe,IAAIH,EAAa,CAACI,EAAGA,EAAE,GAAI,EAAG,WAC7CF,EAAcrB,KAAKsB,GACftC,EAAMuC,EAAI,GAAGtB,MAAQjB,EAAMuC,GAAGtB,QAC9BqB,EAAe,IAAIH,EAAa,EAAG,CAACI,EAAGA,EAAE,GAAI,QAC7CF,EAAcrB,KAAKsB,GACnBjB,EAAKrB,EAAOuC,EAAE,EAAGA,IAd7BC,CAAiBxC,EAAOqC,GACjBA,EA8DX,SAAShB,EAAKrB,EAAOiC,EAAGM,GAKpB,IAAME,EAAOzC,EAAMiC,GACnBjC,EAAMiC,GAAKjC,EAAMuC,GACjBvC,EAAMuC,GAAKE,EC9Mf,IAIMC,EACF,WAAYzB,EAAOF,GAAY,oBAC3BQ,KAAKN,MAAQA,EACbM,KAAKR,UAAYA,GAIJ4B,E,YACjB,WAAYC,GAAQ,IAAD,8BACf,4CAAMA,KAEDC,MAAQ,CACT7C,MAAO,IAJI,E,iFASfuB,KAAKuB,e,mCAML,IAFA,IAAM9C,EAAQ,GACR+C,EAAeC,OAAOC,YACnBhB,EAAI,EAAGA,EAzBN,GAyBqBA,IAAK,CAChC,IAAIiB,EAAOC,EAAU,GAAIJ,EAAe,KACpCK,EAAW,IAAIV,EAAUQ,EAAMjB,GACnCjC,EAAMgB,KAAKoC,GAEf7B,KAAK8B,SAAS,CAACrD,Y,uCAGFsD,GAEb,IADA,IAAMC,EAAS,GACNtB,EAAI,EAAGA,EAAIqB,EAAQnD,OAAQ8B,IAChCsB,EAAOvC,KAAKsC,EAAQrB,GAAGhB,OAG3B,IADA,IAAMjB,EAAQ,GACLiC,EAAI,EAAGA,EAAIsB,EAAOpD,OAAQ8B,IAAK,CACpC,IAAImB,EAAW,IAAIV,EAAUa,EAAOtB,GAAIA,GACxCjC,EAAMgB,KAAKoC,GAEf7B,KAAK8B,SAAS,CAACrD,Y,oCAIf,IAEIwD,EAAiBC,SAASC,eAAe,iBAC7CF,EAAeG,UAAW,EAC1BH,EAAeI,MAAMC,MAJH,OAMlB,IAAIC,EAAcL,SAASC,eAAe,cAC1CI,EAAYH,UAAW,EACvBG,EAAYF,MAAMC,MARA,OAUlB,IAAIE,EAAcN,SAASC,eAAe,cAC1CK,EAAYJ,UAAW,EACvBI,EAAYH,MAAMC,MAZA,OAclB,IAAIG,EAAeP,SAASC,eAAe,eAC3CM,EAAaL,UAAW,EACxBK,EAAaJ,MAAMC,MAhBD,OAkBlB,IAAII,EAAgBR,SAASC,eAAe,kBAC5CO,EAAaN,UAAW,EACxBM,EAAaL,MAAMC,MApBD,S,qCAwBlB,IAEIL,EAAiBC,SAASC,eAAe,iBAC7CF,EAAeG,UAAW,EAC1BH,EAAeI,MAAMC,MAJC,QAMtB,IAAIC,EAAcL,SAASC,eAAe,cAC1CI,EAAYH,UAAW,EACvBG,EAAYF,MAAMC,MARI,QAUtB,IAAIE,EAAcN,SAASC,eAAe,cAC1CK,EAAYJ,UAAW,EACvBI,EAAYH,MAAMC,MAZI,QActB,IAAIG,EAAeP,SAASC,eAAe,eAC3CM,EAAaL,UAAW,EACxBK,EAAaJ,MAAMC,MAhBG,QAkBtB,IAAII,EAAgBR,SAASC,eAAe,kBAC5CO,EAAaN,UAAW,EACxBM,EAAaL,MAAMC,MApBG,U,kCAuBb,IAAD,OACF5D,EDjGP,SAAmBD,GACtB,IAAMC,EAAkB,GAGxB,OAFAD,EAAQD,EAAgBC,EAAOC,GAC/BiE,QAAQC,IAAInE,GACLC,EC6FqBmE,CAAsB7C,KAAKsB,MAAM7C,OACzDuB,KAAK8C,cAGL,IAFA,IAAIC,EAAiB,EACfC,EAAWd,SAASe,uBAAuB,QAJzC,WAKCvC,GAGL,GADqBA,EAAI,IAAM,EACb,CAAC,IAAD,cACuBhC,EAAgBgC,GADvC,GACPwC,EADO,KACOC,EADP,KAERC,EAAeJ,EAASE,GAAcb,MACtCgB,EAAeL,EAASG,GAAcd,MACxCiB,EA3GI,aA6GJA,EADA5C,EAAI,IAAM,EACD,MA7GL,aAiHR6C,YAAW,WACPH,EAAaI,gBAAkBF,EAC/BD,EAAaG,gBAAkBF,IApH3B,EAqHLP,GACHA,SAEAQ,YAAW,WAAO,IAAD,cACqB7E,EAAgBgC,GADrC,GACNwC,EADM,KACQO,EADR,KAEQT,EAASE,GAAcb,MAC/BqB,OAAb,UAAyBD,EAAzB,QA3HI,EA4HLV,GACHA,KAxBCrC,EAAI,EAAGA,EAAIhC,EAAgBE,OAAQ8B,IAAM,EAAzCA,GA4BT6C,YAAW,WACP,IAAMI,EAAcd,EAA4B,EAAKvB,MAAM7C,MAAO,IAClE,EAAKmF,iBAAiBD,GACtB,EAAKE,iBApIO,GAqIZd,EAAiB,M,kCAGZ,IAAD,OACF7C,EAAkB2C,EAAsB7C,KAAKsB,MAAM7C,OACzDuB,KAAK8C,cAGL,IAFA,IAAIC,EAAiB,EAEZrC,EAAI,EAAGA,EAAIR,EAAgBtB,OAAQ8B,IAAK,CAC7C,IAAMsC,EAAWd,SAASe,uBAAuB,QAC3Ca,EAAU5D,EAAgBQ,GAAGX,KAEnB,YAAZ+D,EAAwB,WAAD,kBACc5D,EAAgBQ,GAAGb,QADjC,GAChBqD,EADgB,KACFC,EADE,KAEjBC,EAAeJ,EAASE,GAAcb,MACtCgB,EAAeL,EAASG,GAAcd,MAE5CkB,YAAW,WACPH,EAAaI,gBAFJ,MAGTH,EAAaG,gBAHJ,QArJL,EAyJLT,GACHA,IACAQ,YAAW,WACPH,EAAaI,gBA3JT,aA4JJH,EAAaG,gBA5JT,eADA,EA8JLT,GACHA,IAdwB,GAeL,SAAZe,GAAqB,WAAD,kBACU5D,EAAgBQ,GAAGZ,KAD7B,GACpBoD,EADoB,KACNC,EADM,KAErBC,EAAeJ,EAASE,GAAcb,MACtCgB,EAAeL,EAASG,GAAcd,MAE5CkB,YAAW,WACPH,EAAaI,gBAFJ,SAGTH,EAAaG,gBAHJ,WApKL,EAwKLT,GACHA,IACAQ,YAAW,WACP,IAAMQ,EAAaX,EAAaM,OAChCN,EAAaM,OAASL,EAAaK,OACnCL,EAAaK,OAASK,EACtBX,EAAaI,gBA7KT,aA8KJH,EAAaG,gBA9KT,eADA,EAgLLT,GACHA,IAjB4B,GAqBpCQ,YAAW,WACP,EAAKK,iBAAiB,EAAKtC,MAAM7C,OACjC,EAAKoF,iBAvLO,GAwLZd,EAAiB,M,mCAGX,IAAD,OACHjC,EAAgB+B,EAAuB7C,KAAKsB,MAAM7C,OACxDuB,KAAK8C,cAGL,IAFA,IAAIC,EAAiB,EAEZrC,EAAI,EAAGA,EAAII,EAAclC,OAAQ8B,IAAK,CAC3C,IAAMsC,EAAWd,SAASe,uBAAuB,QAC3Ca,EAAUhD,EAAcJ,GAAGX,KAEjB,YAAZ+D,EAAwB,WAAD,kBACchD,EAAcJ,GAAGb,QAD/B,GAChBqD,EADgB,KACFC,EADE,KAEjBC,EAAeJ,EAASE,GAAcb,MACtCgB,EAAeL,EAASG,GAAcd,MAE5CkB,YAAW,WACPH,EAAaI,gBAFJ,MAGTH,EAAaG,gBAHJ,QAxML,EA4MLT,GACHQ,YAAW,WACPH,EAAaI,gBA7MT,aA8MJH,EAAaG,gBA9MT,eADA,GAgNJT,EAAiB,IACrBA,GAAkB,EAbM,GAcL,SAAZe,GAAqB,WAAD,kBACUhD,EAAcJ,GAAGZ,KAD3B,GACpBoD,EADoB,KACNC,EADM,KAErBC,EAAeJ,EAASE,GAAcb,MACtCgB,EAAeL,EAASG,GAAcd,MAC5CkB,YAAW,WACP,IAAMQ,EAAaX,EAAaM,OAChCN,EAAaM,OAASL,EAAaK,OACnCL,EAAaK,OAASK,IAzNlB,EA0NLhB,GACHA,GAAkB,EATU,GAapCQ,YAAW,WACP,EAAKK,iBAAiB,EAAKtC,MAAM7C,OACjC,EAAKoF,iBAjOO,GAkOZd,EAAiB,M,sCAGR,IAAD,OACNjC,EAAgB+B,EAAuB7C,KAAKsB,MAAM7C,OACxDuB,KAAK8C,cAGL,IAFA,IAAIC,EAAiB,EAEZrC,EAAI,EAAGA,EAAII,EAAclC,OAAQ8B,IAAK,CAC3C,IAAMsC,EAAWd,SAASe,uBAAuB,QAC3Ca,EAAUhD,EAAcJ,GAAGX,KAEjB,YAAZ+D,EAAwB,WAAD,kBACchD,EAAcJ,GAAGb,QAD/B,GAChBqD,EADgB,KACFC,EADE,KAEjBC,EAAeJ,EAASE,GAAcb,MACtCgB,EAAeL,EAASG,GAAcd,MAE5CkB,YAAW,WACPH,EAAaI,gBAFJ,MAGTH,EAAaG,gBAHJ,QAlPL,EAsPLT,GACHQ,YAAW,WACPH,EAAaI,gBAvPT,aAwPJH,EAAaG,gBAxPT,eADA,GA0PJT,EAAiB,IACrBA,GAAkB,EAbM,GAcL,SAAZe,GAAqB,WAAD,kBACUhD,EAAcJ,GAAGZ,KAD3B,GACpBoD,EADoB,KACNC,EADM,KAErBC,EAAeJ,EAASE,GAAcb,MACtCgB,EAAeL,EAASG,GAAcd,MAC5CkB,YAAW,WACP,IAAMQ,EAAaX,EAAaM,OAChCN,EAAaM,OAASL,EAAaK,OACnCL,EAAaK,OAASK,IAnQlB,EAoQLhB,GACHA,GAAkB,EATU,GAapCQ,YAAW,WACP,EAAKK,iBAAiB,EAAKtC,MAAM7C,OACjC,EAAKoF,iBA3QO,GA4QZd,EAAiB,M,iCAIrB,IAAK,IAAIrC,EAAI,EAAGA,EAAI,EAAGA,Q,+BAOjB,IAAD,OACEjC,EAASuB,KAAKsB,MAAd7C,MACP,OACI,yBAAKuF,UAAU,aACX,yBAAKA,UAAU,eACX,4BAAQC,GAAG,gBAAgBC,QAAS,kBAAM,EAAK3C,eAA/C,uBACA,4BAAQ0C,GAAG,aAAaC,QAAS,kBAAM,EAAKC,cAA5C,iBACA,4BAAQF,GAAG,aAAaC,QAAS,kBAAM,EAAKjE,cAA5C,iBACA,4BAAQgE,GAAG,cAAcC,QAAS,kBAAM,EAAKrD,eAA7C,kBACA,4BAAQoD,GAAG,iBAAiBC,QAAS,kBAAM,EAAKE,kBAAhD,sBAEJ,yBAAKJ,UAAU,kBACVvF,EAAM4F,KAAI,SAACC,EAAMC,GAAP,OACP,yBAAKP,UAAU,OAAOQ,IAAKD,EAAOlC,MAAO,CAACqB,OAAO,GAAD,OAAKY,EAAK5E,MAAV,kB,GAzRzB+E,IAAMC,WAkSrD,SAAS9C,EAAU+C,EAAKC,GACpB,OAAO9F,KAAKC,MAAMD,KAAK+F,UAAYD,EAAMD,EAAM,GAAKA,G,MCtSzCG,MARf,WACE,OACE,yBAAKd,UAAU,OACb,kBAAC,EAAD,QCKce,QACW,cAA7BtD,OAAOuD,SAASC,UAEe,UAA7BxD,OAAOuD,SAASC,UAEhBxD,OAAOuD,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASlD,SAASC,eAAe,SD2H3C,kBAAmBkD,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.2dd17400.chunk.js","sourcesContent":["///////////////////////////////////////////////////////////////////////////////\r\n//                              MERGE SORT                                   //\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nexport function mergeSort(rects) {\r\n    const animationsMerge = [];\r\n    rects = mergeSortHelper(rects, animationsMerge);\r\n    console.log(rects);\r\n    return animationsMerge;\r\n}\r\n\r\nexport function mergeSortHelper(rects, animationsMerge) {\r\n    let rectsLength = rects.length;\r\n\tif (rectsLength < 2) return rects;\r\n\r\n\tlet mid = Math.floor(rectsLength / 2);\r\n\tlet left = rects.slice(0, mid);\r\n\tlet right = rects.slice(mid);\r\n\r\n\treturn merge(mergeSortHelper(left, animationsMerge), mergeSortHelper(right, animationsMerge), animationsMerge);\r\n}\r\n\r\nfunction merge(left, right, animationsMerge) {\r\n\tlet sortedArr = [];\r\n\tlet leftLength = left.length;\r\n\tlet rightLength = right.length;\r\n\tlet l = 0;\r\n\tlet r = 0;\r\n    let currIndex = left[0].currIndex;\r\n\r\n\twhile (l < leftLength && r < rightLength) {\r\n        animationsMerge.push([left[l].currIndex, right[r].currIndex]);\r\n        animationsMerge.push([left[l].currIndex, right[r].currIndex]);\r\n\t\tif (left[l].value < right[r].value) {\r\n            animationsMerge.push([currIndex, left[l].value]);\r\n            left[l].currIndex = currIndex;\r\n            currIndex++;\r\n            sortedArr.push(left[l]);\r\n\t\t\tl++;\r\n\t\t} else {\r\n            animationsMerge.push([currIndex, right[r].value]);\r\n            right[r].currIndex = currIndex;\r\n            currIndex++;\r\n\t\t\tsortedArr.push(right[r]);\r\n\t\t\tr++;\r\n        }\r\n\t}\r\n\r\n\twhile (l < leftLength) {\r\n        animationsMerge.push([left[l].currIndex, left[l].currIndex]);\r\n        animationsMerge.push([left[l].currIndex, left[l].currIndex]);\r\n        animationsMerge.push([currIndex, left[l].value]);\r\n        left[l].currIndex = currIndex;\r\n        currIndex++;\r\n\t\tsortedArr.push(left[l]);\r\n\t\tl++;\r\n\t}\r\n\r\n\twhile (r < rightLength) {\r\n        animationsMerge.push([right[r].currIndex, right[r].currIndex]);\r\n        animationsMerge.push([right[r].currIndex, right[r].currIndex]);\r\n        animationsMerge.push([currIndex, right[r].value]);\r\n        right[r].currIndex = currIndex;\r\n        currIndex++;\r\n\t\tsortedArr.push(right[r]);\r\n\t\tr++;\r\n    }\r\n    \r\n\treturn sortedArr;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n//                              QUICK SORT                                   //\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nclass AnimationQuick {\r\n    constructor(compare, swap, type) {\r\n        this.compare = compare;\r\n        this.swap = swap;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\nexport function quickSort(rects) {\r\n    const animationsQuick = [];\r\n    const rectsLength = rects.length - 1;\r\n    \r\n    quickSortHelper(rects, 0, rectsLength, animationsQuick);\r\n    return animationsQuick;\r\n}\r\n\r\nfunction quickSortHelper(rects, low, high, animationsQuick) {\r\n    let pivot;\r\n    let partitionIndex;\r\n\r\n    if (low < high) {\r\n        pivot = high;\r\n        partitionIndex = partition(rects, pivot, low, high, animationsQuick)\r\n\r\n        quickSortHelper(rects, low, partitionIndex - 1, animationsQuick);\r\n        quickSortHelper(rects, partitionIndex + 1, high, animationsQuick);\r\n    }\r\n    return rects;\r\n}\r\n\r\nfunction partition(rects, pivot, low, high, animationsQuick) {\r\n    let pivotValue = rects[pivot];\r\n    let partitionIndex = low;\r\n    let animationQuick;\r\n\r\n    for (let i = low; i < high; i++) {\r\n        animationQuick = new AnimationQuick([i, pivot], 0, 'compare');\r\n        animationsQuick.push(animationQuick);\r\n        if (rects[i].value < pivotValue.value) {\r\n            animationQuick = new AnimationQuick(0, [i, partitionIndex], 'swap');\r\n            animationsQuick.push(animationQuick);\r\n            swap(rects, i, partitionIndex);\r\n            partitionIndex++;\r\n        }\r\n    }\r\n    animationQuick = new AnimationQuick(0, [high, partitionIndex], 'swap');\r\n    animationsQuick.push(animationQuick);\r\n    swap(rects, high, partitionIndex);\r\n    return partitionIndex;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n//                              BUBBLE SORT                                  //\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nclass AnimationBub {\r\n    constructor(compare, swap, type) {\r\n        this.compare = compare;\r\n        this.swap = swap;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\nexport function bubbleSort(rects) {\r\n    const animationsBub = [];\r\n    bubbleSortHelper(rects, animationsBub);\r\n    return animationsBub;\r\n}\r\n\r\nfunction bubbleSortHelper(rects, animationsBub) {\r\n    let len = rects.length;\r\n    let animationBub;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        for (let j = 1; j <= i; j++) {\r\n            animationBub = new AnimationBub([j, j-1], 0, 'compare');\r\n            animationsBub.push(animationBub);\r\n            if (rects[j - 1].value > rects[j].value) {\r\n                animationBub = new AnimationBub(0, [j, j-1], 'swap');\r\n                animationsBub.push(animationBub);\r\n                swap(rects, j-1, j);\r\n            }\r\n        }\r\n    }\r\n    return rects;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n//                              SELECTION SORT                               //\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nclass AnimationSelect {\r\n    constructor(compare, swap, type) {\r\n        this.compare = compare;\r\n        this.swap = swap;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\nexport function selectionSort(rects) {\r\n    const animationsBub = [];\r\n    selectionSortHelper(rects, animationsBub);\r\n    return animationsBub;\r\n}\r\n\r\nexport function selectionSortHelper(rects, animationsSelect) {\r\n    let minIndex;\r\n    let len = rects.length;\r\n    let animationSelect;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        minIndex = i;\r\n        for (let j = i + 1; j < len; j++) {\r\n            animationSelect = new AnimationSelect([j, minIndex], 0, 'compare');\r\n            animationsSelect.push(animationSelect);\r\n            if (rects[j].value < rects[minIndex].value) {\r\n                minIndex = j;\r\n            }\r\n        }\r\n        animationSelect = new AnimationSelect(0, [i, minIndex], 'swap');\r\n        animationsSelect.push(animationSelect);\r\n        swap(rects, i, minIndex);\r\n    }\r\n    return rects;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n//                              USEFUL FUNCTIONS                             //\r\n///////////////////////////////////////////////////////////////////////////////\r\nfunction swap(rects, i, j) {\r\n    // const tempIndex = rects[i].currIndex;\r\n    // rects[i].currIndex = rects[j].currIndex;\r\n    // rects[j].currIndex = tempIndex;\r\n\r\n    const temp = rects[i];\r\n    rects[i] = rects[j];\r\n    rects[j] = temp;\r\n}\r\n\r\nfunction randValue(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\n","import React from 'react';\r\nimport './SortingVisualizer.css';\r\nimport * as sortingAlgs from '../SortingAlgorithms/sortingAlgs';\r\n\r\nconst ANIMATION_SPEED = 1;\r\nconst ORIGINAL_COLOUR = 'darkviolet';\r\nconst NUM_RECTS = 80;\r\n\r\nclass Rectangle {\r\n    constructor(value, currIndex) {\r\n        this.value = value;\r\n        this.currIndex = currIndex;\r\n    }\r\n}\r\n\r\nexport default class SortingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            rects: [],\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resetRects();\r\n    }\r\n\r\n    resetRects() {\r\n        const rects = [];\r\n        const screenHeight = window.innerHeight;\r\n        for (let i = 0; i < NUM_RECTS; i++) {\r\n            let rand = randValue(10, screenHeight - 100);\r\n            let tempRect = new Rectangle(rand, i);\r\n            rects.push(tempRect);\r\n        }\r\n        this.setState({rects});\r\n    }\r\n\r\n    resetRectIndices(rectsIn) {\r\n        const values = [];\r\n        for (let i = 0; i < rectsIn.length; i++) {\r\n            values.push(rectsIn[i].value)\r\n        }\r\n        const rects = [];\r\n        for (let i = 0; i < values.length; i++) {\r\n            let tempRect = new Rectangle(values[i], i);\r\n            rects.push(tempRect);\r\n        }\r\n        this.setState({rects});\r\n    }\r\n\r\n    lockButtons() {\r\n        let blockColour = 'gray';\r\n\r\n        let generateButton = document.getElementById('generate-nums');\r\n        generateButton.disabled = true;\r\n        generateButton.style.color = blockColour;\r\n        \r\n        let mergeButton = document.getElementById('merge-sort');\r\n        mergeButton.disabled = true;\r\n        mergeButton.style.color = blockColour;\r\n\r\n        let quickButton = document.getElementById('quick-sort');\r\n        quickButton.disabled = true;\r\n        quickButton.style.color = blockColour;\r\n        \r\n        let bubbleButton = document.getElementById('bubble-sort');\r\n        bubbleButton.disabled = true;\r\n        bubbleButton.style.color = blockColour;\r\n\r\n        let selectButton =  document.getElementById('selection-sort');\r\n        selectButton.disabled = true;\r\n        selectButton.style.color = blockColour;\r\n    }\r\n\r\n    resetButtons() {\r\n        let unblockedColour = 'white';\r\n\r\n        let generateButton = document.getElementById('generate-nums');\r\n        generateButton.disabled = false;\r\n        generateButton.style.color = unblockedColour;\r\n        \r\n        let mergeButton = document.getElementById('merge-sort');\r\n        mergeButton.disabled = false;\r\n        mergeButton.style.color = unblockedColour;\r\n\r\n        let quickButton = document.getElementById('quick-sort');\r\n        quickButton.disabled = false;\r\n        quickButton.style.color = unblockedColour;\r\n        \r\n        let bubbleButton = document.getElementById('bubble-sort');\r\n        bubbleButton.disabled = false;\r\n        bubbleButton.style.color = unblockedColour;\r\n\r\n        let selectButton =  document.getElementById('selection-sort');\r\n        selectButton.disabled = false;\r\n        selectButton.style.color = unblockedColour;\r\n    }\r\n\r\n    mergeSort() {\r\n        const animationsMerge = sortingAlgs.mergeSort(this.state.rects);\r\n        this.lockButtons();\r\n        let animationTimer = 0;\r\n        const rectList = document.getElementsByClassName('rect');\r\n        for (let i = 0; i < animationsMerge.length; i++) {\r\n            \r\n            const colourChange = i % 3 !== 2;\r\n            if (colourChange) {\r\n                const [rectOneIndex, rectTwoIndex] = animationsMerge[i];\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                let colour = ORIGINAL_COLOUR;\r\n                if (i % 3 === 0) {\r\n                    colour = 'red';\r\n                } else {\r\n                    colour = ORIGINAL_COLOUR;\r\n                }\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                    rectTwoStyle.backgroundColor = colour;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                animationTimer++;\r\n            } else {\r\n                setTimeout(() => {\r\n                    const [rectOneIndex, newHeight] = animationsMerge[i];\r\n                    const rectOneStyle = rectList[rectOneIndex].style;\r\n                    rectOneStyle.height = `${newHeight}px`;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                animationTimer++;\r\n            }\r\n        }\r\n\r\n        setTimeout(() => {\r\n            const sortedRects = sortingAlgs.mergeSortHelper(this.state.rects, []);\r\n            this.resetRectIndices(sortedRects);\r\n            this.resetButtons();\r\n        }, (animationTimer + 1) * ANIMATION_SPEED);\r\n    }\r\n\r\n    quickSort() {\r\n        const animationsQuick = sortingAlgs.quickSort(this.state.rects);\r\n        this.lockButtons();\r\n        let animationTimer = 0;\r\n\r\n        for (let i = 0; i < animationsQuick.length; i++) {\r\n            const rectList = document.getElementsByClassName('rect');\r\n            const aniType = animationsQuick[i].type;\r\n\r\n            if (aniType === 'compare') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsQuick[i].compare;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                let colour = 'red';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                    rectTwoStyle.backgroundColor = colour;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                animationTimer++;\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                    rectTwoStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                animationTimer++\r\n            } else if (aniType === 'swap') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsQuick[i].swap;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                let colour = 'yellow';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                    rectTwoStyle.backgroundColor = colour;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                animationTimer++\r\n                setTimeout(() => {\r\n                    const tempHeight = rectOneStyle.height;\r\n                    rectOneStyle.height = rectTwoStyle.height;\r\n                    rectTwoStyle.height = tempHeight;\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                    rectTwoStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                animationTimer++\r\n            }\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.resetRectIndices(this.state.rects);\r\n            this.resetButtons();\r\n        }, (animationTimer + 1) * ANIMATION_SPEED);\r\n    }\r\n\r\n    bubbleSort() {\r\n        const animationsBub = sortingAlgs.bubbleSort(this.state.rects);\r\n        this.lockButtons();\r\n        let animationTimer = 0;\r\n\r\n        for (let i = 0; i < animationsBub.length; i++) {\r\n            const rectList = document.getElementsByClassName('rect');\r\n            const aniType = animationsBub[i].type;\r\n\r\n            if (aniType === 'compare') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsBub[i].compare;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                let colour = 'red';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                    rectTwoStyle.backgroundColor = colour;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                    rectTwoStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 2) * ANIMATION_SPEED);\r\n                animationTimer += 3;\r\n            } else if (aniType === 'swap') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsBub[i].swap;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                setTimeout(() => {\r\n                    const tempHeight = rectOneStyle.height;\r\n                    rectOneStyle.height = rectTwoStyle.height;\r\n                    rectTwoStyle.height = tempHeight;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                animationTimer += 1;\r\n            }\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.resetRectIndices(this.state.rects);\r\n            this.resetButtons();\r\n        }, (animationTimer + 1) * ANIMATION_SPEED);\r\n    }\r\n\r\n    selectionSort() {\r\n        const animationsBub = sortingAlgs.bubbleSort(this.state.rects);\r\n        this.lockButtons();\r\n        let animationTimer = 0;\r\n\r\n        for (let i = 0; i < animationsBub.length; i++) {\r\n            const rectList = document.getElementsByClassName('rect');\r\n            const aniType = animationsBub[i].type;\r\n\r\n            if (aniType === 'compare') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsBub[i].compare;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                let colour = 'red';\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = colour;\r\n                    rectTwoStyle.backgroundColor = colour;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                setTimeout(() => {\r\n                    rectOneStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                    rectTwoStyle.backgroundColor = ORIGINAL_COLOUR;\r\n                }, (animationTimer + 5) * ANIMATION_SPEED);\r\n                animationTimer += 6;\r\n            } else if (aniType === 'swap') {\r\n                const [rectOneIndex, rectTwoIndex] = animationsBub[i].swap;\r\n                const rectOneStyle = rectList[rectOneIndex].style;\r\n                const rectTwoStyle = rectList[rectTwoIndex].style;\r\n                setTimeout(() => {\r\n                    const tempHeight = rectOneStyle.height;\r\n                    rectOneStyle.height = rectTwoStyle.height;\r\n                    rectTwoStyle.height = tempHeight;\r\n                }, animationTimer * ANIMATION_SPEED);\r\n                animationTimer += 1;\r\n            }\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.resetRectIndices(this.state.rects);\r\n            this.resetButtons();\r\n        }, (animationTimer + 1) * ANIMATION_SPEED);\r\n    }\r\n\r\n    testSort() {\r\n        for (let i = 0; i < 1; i++) {\r\n            //let testArrayOne = generateNums(10);\r\n            //let testArrayTwo = [...testArrayOne];\r\n        }\r\n    \r\n    }\r\n\r\n    render() {\r\n        const {rects} = this.state;\r\n        return (\r\n            <div className=\"container\">\r\n                <div className=\"options-bar\">\r\n                    <button id=\"generate-nums\" onClick={() => this.resetRects()}> Generate Numbers  </button>\r\n                    <button id=\"merge-sort\" onClick={() => this.mergeSort()}> Merge Sort  </button>\r\n                    <button id=\"quick-sort\" onClick={() => this.quickSort()}> Quick Sort  </button>\r\n                    <button id=\"bubble-sort\" onClick={() => this.bubbleSort()}> Bubble Sort  </button>\r\n                    <button id=\"selection-sort\" onClick={() => this.selectionSort()}> Selection Sort  </button>\r\n                </div>\r\n                <div className=\"rect-container\">\r\n                    {rects.map((rect, index) => (\r\n                        <div className=\"rect\" key={index} style={{height: `${rect.value}px`}} >\r\n                        </div>\r\n                    ))}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction randValue(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\nfunction generateNums(howMany) {\r\n    const nums = [];\r\n        for (let i = 0; i < howMany; i++) {\r\n            let rand = randValue(10, 1000);\r\n            nums.push(rand);\r\n        }\r\n    return nums;\r\n}\r\n\r\nfunction arraysEqual(arrOne, arrTwo) {\r\n    if (arrOne.length !== arrTwo.length) {\r\n        console.log()\r\n        return false;\r\n    } else {\r\n        for (let i = 0; i < arrOne.length; i++) {\r\n            if (arrOne[i] !== arrTwo[i]) return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingScript';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}